import { parseArgs } from 'util';
import { readdir } from 'node:fs/promises';

type ChainDetails = {
  name: string;
  explorerUrl: string;
  isTestnet: boolean;
}

const chains: {[chainId: number]: ChainDetails } = {
  8453: {
    name: 'Base',
    explorerUrl: 'https://basescan.org',
    isTestnet: false,
  },
  84532: {
    name: 'Base Sepolia',
    explorerUrl: 'https://sepolia.basescan.org',
    isTestnet: true,
  },
  130: {
    name: 'Unichain',
    explorerUrl: 'https://uniscan.xyz',
    isTestnet: false,
  },
  1301: {
    name: 'Unichain Sepolia',
    explorerUrl: 'https://sepolia.uniscan.xyz',
    isTestnet: true,
  },
  57073: {
    name: 'Ink',
    explorerUrl: 'https://explorer.inkonchain.com',
    isTestnet: false,
  },
  763373: {
    name: 'Ink Sepolia',
    explorerUrl: 'https://explorer-sepolia.inkonchain.com',
    isTestnet: true,
  },
  480: {
    name: 'World Chain',
    explorerUrl: 'https://worldscan.org',
    isTestnet: false,
  },
  4801: {
    name: 'World Chain Sepolia',
    explorerUrl: 'https://worldchain-sepolia.explorer.alchemy.com',
    isTestnet: true,
  },
  10143: {
    name: 'Monad Testnet',
    explorerUrl: 'https://testnet.monadscan.com',
    isTestnet: true,
  },
  421614: {
    name: 'Arbitrum Sepolia',
    explorerUrl: 'https://sepolia.arbiscan.io',
    isTestnet: true,
  },
  143: {
    name: 'Monad Mainnet',
    explorerUrl: 'https://monadscan.com',
    isTestnet: false,
  },
  4326: {
    name: 'MegaETH Mainnet',
    explorerUrl: 'https://megaeth.blockscout.com',
    isTestnet: false,
  },
  6343: {
    name: 'MegaETH Testnet',
    explorerUrl: 'https://megaeth-testnet-v2.blockscout.com',
    isTestnet: true,
  },
  1: {
    name: 'Ethereum Mainnet',
    explorerUrl: 'https://etherscan.io',
    isTestnet: false,
  },
  11155111: {
    name: 'Sepolia',
    explorerUrl: 'https://sepolia.etherscan.io',
    isTestnet: true,
  },
};

type Transaction = {
  hash: `0x${string}`;
  contractName: string;
  transactionType: 'CREATE' | 'CREATE2' | 'CALL';
  contractAddress: `0x${string}`;
  function?: string;
  arguments: `0x${string}`[];
  additionalContracts: {
    transactionType: 'CREATE' | 'CREATE2';
    contractName: null | string;
    address: `0x${string}`;
  }[];
}

type Broadcast = {
  transactions: Transaction[];
  commit: string;
  chain: number;
  timestamp: number;
}

type Deployment = {
  contractName: string;
  contractAddress: `0x${string}`;
  hash: `0x${string}`;
  arguments: `0x${string}`[];  
  commit: string;
  timestamp: number;
};

function shorten(a: string, length: number = 4): string {
  return `${a.slice(0, length + 2)}...${a.slice(-length)}`;
}

// Foundry changed the timestamp from s to ms so we need to handle both cases
function convertTimestamp(timestamp: number): string {
  return new Date(
    new Date(timestamp).getFullYear() === 1970 ? timestamp * 1000 :timestamp
  ).toUTCString();
}

function generateTable(deployments: Deployment[], chainId: string): string {
  const explorerUrl = chains[chainId].explorerUrl;

  let content = `| Contract | Address | Transaction | Commit |\n`;
  content += '|---|---|---|---|\n';

  deployments.forEach((d) => {
    content += `| ${d.contractName}`;
    content += ` | [${shorten(d.contractAddress)}](${explorerUrl}/address/${d.contractAddress})`;
    content += ` | [${shorten(d.hash, 4)}](${explorerUrl}/tx/${d.hash})`;
    content += ` | [${d.commit}](https://github.com/whetstoneresearch/doppler/commit/${d.commit})`;
    content += ` | \n`;
  });

  return content;
}

function getLatestDeployments(deployments: Deployment[]): Deployment[] {
  const latestDeployments: {[key: string]: Deployment} = {};

  deployments.forEach((deployment) => {
    if (!latestDeployments[deployment.contractName]) {
      latestDeployments[deployment.contractName] = deployment;
    } else {
      if (latestDeployments[deployment.contractName].timestamp < deployment.timestamp) {
        latestDeployments[deployment.contractName] = deployment;
      }
    }
  });

  return Object.values(latestDeployments);
}

async function generateHistoryLogs(): Promise<void> {
  // First let's find all the broadcast files generated by Foundry
  const broadcastFiles = await readdir('./broadcast', {
    recursive: true,
  });

  // Then we keep only the .json files and filter out the dry runs and multi broadcasts
  const jsonFiles = broadcastFiles.filter((file) => file.endsWith('.json')
    && !file.includes('dry') && !file.includes('latest') && !file.startsWith('multi'));

  // Then we're going to iterate over each file to fetch the deployments
  const deployments: {[chainId: string]: Deployment[] } = {};

  for (const file of jsonFiles) {
    const filePath = `./broadcast/${file}`;
    const raw = Bun.file(filePath);
    const broadcast: Broadcast = await raw.json();

    if (broadcast.chain === 31337) {
      continue;
    }

    if (deployments[broadcast.chain] === undefined) {
      deployments[broadcast.chain] = [];
    }

    const transactions = broadcast.transactions
      .filter((transaction) => (transaction.transactionType === 'CREATE' || transaction.transactionType === 'CREATE2')
        && transaction.hash !== null && transaction.contractName !== null && transaction.contractName !== 'AirlockMultisig')
      .map(transaction => ({
        contractName: transaction.contractName,
        contractAddress: transaction.contractAddress,
        hash: transaction.hash,
        arguments: transaction.arguments,
        commit: broadcast.commit as `0x${string}`,
        timestamp: broadcast.timestamp,
      }));

    deployments[broadcast.chain].push(...transactions);

    // Also process additionalContracts from individual chain broadcasts
    for (const transaction of broadcast.transactions) {
      if (transaction.additionalContracts) {
        for (const additional of transaction.additionalContracts) {
          if ((additional.transactionType === 'CREATE' || additional.transactionType === 'CREATE2')
            && additional.contractName !== null
            && additional.contractName !== 'AirlockMultisig'
            && transaction.hash !== null
          ) {
            deployments[broadcast.chain].push({
              contractName: additional.contractName,
              contractAddress: additional.address,
              hash: transaction.hash,
              arguments: [],
              commit: broadcast.commit as `0x${string}`,
              timestamp: broadcast.timestamp,
            });
          }
        }
      }
    }
  }

  // Foundry now supports multichain broadcasts but these files must be handled differently
  const multiBroadcastFiles = await readdir('./broadcast/multi', {
    recursive: true,
  });

  // Filter to JSON files, excluding dry runs. For -latest dirs, only include if no timestamped version exists.
  const additionalJsonFiles = multiBroadcastFiles
    .filter((file) => file.endsWith('.json') && !file.includes('dry'))
    .filter((file) => {
      if (!file.includes('-latest')) return true;
      // Check if a timestamped version exists for this script
      const scriptName = file.split('-latest')[0];
      return !multiBroadcastFiles.some((f) => f.startsWith(scriptName) && !f.includes('-latest') && f.endsWith('.json'));
    });

  for (const file of additionalJsonFiles) {
    const filePath = `./broadcast/multi/${file}`;
    const raw = Bun.file(filePath);
    const multi: {
      deployments: Broadcast[];
    } = await raw.json();

    for (const broadcast of multi.deployments) {
      if (broadcast.chain === 31337 || broadcast.chain === undefined) {
        continue;
      }

      // Check if this broadcast has any contracts deployed via additionalContracts
      const hasAdditionalContracts = broadcast.transactions.some(tx =>
        tx.additionalContracts.some(ac =>
          (ac.transactionType === 'CREATE' || ac.transactionType === 'CREATE2') && ac.contractName !== null
        )
      );

     for (const transaction of broadcast.transactions) {
        if ((
          transaction.transactionType === 'CREATE' || transaction.transactionType === 'CREATE2')
          && transaction.hash !== null && transaction.contractName !== null
        ) {
          if (deployments[broadcast.chain] === undefined) {
            deployments[broadcast.chain] = [];
          }

          deployments[broadcast.chain].push({
            contractName: transaction.contractName,
            contractAddress: transaction.contractAddress,
            hash: transaction.hash,
            arguments: transaction.arguments,
            commit: broadcast.commit as `0x${string}`,
            timestamp: broadcast.timestamp,
          });
        }

        // A bit tricky but we also need to check if contracts were deployed as additional contracts
        for (const additional of transaction.additionalContracts) {
          if ((additional.transactionType === 'CREATE' || additional.transactionType === 'CREATE2')
            && additional.contractName !== null && transaction.hash !== null
          ) {
            if (deployments[broadcast.chain] === undefined) {
              deployments[broadcast.chain] = [];
            }

            deployments[broadcast.chain].push({
              contractName: additional.contractName,
              contractAddress: additional.address,
              hash: transaction.hash,
              arguments: [],
              commit: broadcast.commit as `0x${string}`,
              timestamp: broadcast.timestamp,
            });
          }
        }

        // Handle CREATE3 deployments recorded via StdConfig.set(string,address) calls
        // Only use this fallback if no contracts were deployed via additionalContracts
        // These have function "set(string,address)" and arguments [contractName, deployedAddress]
        if (!hasAdditionalContracts
          && transaction.transactionType === 'CALL'
          && transaction.function === 'set(string,address)'
          && transaction.arguments?.length === 2
          && transaction.hash !== null
        ) {
          const [contractName, deployedAddress] = transaction.arguments;
          // Convert snake_case config name to PascalCase contract name (e.g., "airlock" -> "Airlock")
          const formattedName = contractName.split('_').map((s: string) => s.charAt(0).toUpperCase() + s.slice(1)).join('');

          if (deployments[broadcast.chain] === undefined) {
            deployments[broadcast.chain] = [];
          }

          deployments[broadcast.chain].push({
            contractName: formattedName,
            contractAddress: deployedAddress,
            hash: transaction.hash,
            arguments: [],
            commit: broadcast.commit as `0x${string}`,
            timestamp: broadcast.timestamp,
          });
        }
      }
    }
  }

  // Now we're going to generate the history logs for each chain
  for (const chainId in deployments) {
    if (deployments[chainId].length === 0) {
      continue;
    }

    // Filter out any deployments with null/undefined contractName
    deployments[chainId] = deployments[chainId].filter(d => d.contractName);

    let content = `# Deployments on ${chains[chainId].name} (${chainId})\n`;
    let timestamps: {[key: number]: Deployment[]} = {};

    deployments[chainId].forEach((d) => {
      if (!timestamps[d.timestamp]) {
        timestamps[d.timestamp] = [];
      }
      timestamps[d.timestamp].push(d);
    });

    const sortedTimestamps = Object.keys(timestamps).sort((a, b) => Number(b) - Number(a));

    for (const timestamp of sortedTimestamps) {
      const t = timestamps[timestamp];
      content += `### ${convertTimestamp(t[0].timestamp)}\n`;
      content += generateTable(t, chainId);
    }

    await Bun.write(`deployments/${chainId}.md`, content);
  }

  // Finally we generate the main Deployments.md file
  const mainnetLabels: string[] = [];
  let mainnetDeployments = '## Mainnet Deployments\n';

  for (const chainId in deployments) {
    if (deployments[chainId].length === 0 || chains[chainId].isTestnet) {
      continue;
    }

    // Filter out any deployments with null/undefined contractName
    deployments[chainId] = deployments[chainId].filter(d => d.contractName);
    deployments[chainId].sort((a, b) => a.contractName.localeCompare(b.contractName));
    let latestDeployments = getLatestDeployments(deployments[chainId]);
    latestDeployments = latestDeployments.filter(d => d.contractName !== 'AirlockMultisig');
    mainnetDeployments += `### ${chains[chainId].name} (${chainId})\n`;
    mainnetDeployments += generateTable(latestDeployments, chainId);
    mainnetLabels.push(chains[chainId].name);
  }

  const testnetLabels: string[] = [];
  let testnetDeployments = '## Testnet Deployments\n';

  for (const chainId in deployments) {
    if (deployments[chainId].length === 0 || !chains[chainId].isTestnet) {
      continue;
    }

    // Filter out any deployments with null/undefined contractName
    deployments[chainId] = deployments[chainId].filter(d => d.contractName);
    deployments[chainId].sort((a, b) => a.contractName.localeCompare(b.contractName));
    const latestDeployments = getLatestDeployments(deployments[chainId]);
    testnetDeployments += `### ${chains[chainId].name} (${chainId})\n`;
    testnetDeployments += generateTable(latestDeployments, chainId);
    testnetLabels.push(chains[chainId].name);
  }

  await Bun.write(`./Deployments.md`, generateDeploymentsFile(mainnetLabels, mainnetDeployments, testnetLabels, testnetDeployments));
  
  // Generate JSON file for SDK consumption
  const addressesJson: {[chainId: string]: {[contractName: string]: string}} = {};
  
  for (const chainId in deployments) {
    if (deployments[chainId].length === 0) {
      continue;
    }
    
    const latestDeployments = getLatestDeployments(deployments[chainId]);
    addressesJson[chainId] = {};
    
    latestDeployments.forEach((deployment) => {
      addressesJson[chainId][deployment.contractName] = deployment.contractAddress;
    });
  }
  
  await Bun.write(`./Deployments.json`, JSON.stringify(addressesJson, null, 2));
}

function generateDeploymentsFile(mainnetLabels: string[], mainnets: string, testnetLabels: string[], testnets): string {
  return `---
icon: pen-field
---

# Contract Addresses

Here are the networks that Doppler is officially deployed to:

- Mainnets: ${mainnetLabels.join(', ')}
- Testnets: ${testnetLabels.join(', ')}

{% hint style="danger" %}
If there are contracts not reflected here but claiming to be instances of Doppler, they are not considered canonical. Use with caution. :rotating_light:
{% endhint %}\n
${mainnets}
${testnets}
`;
}

async function main() {
  const { values } = parseArgs({
    args: Bun.argv,
    options: {
      output: {
        type: 'string',
      },
    },
    strict: true,
    allowPositionals: true,
  });

  switch (values.output) {
    case 'history':
      await generateHistoryLogs();
      break;
    default:
      console.error(`Unknown command: ${values.output}`);
      process.exit(1);
  }
}

main().catch((error) => {
  console.error('Fatal error:', error);
  process.exit(1);
});